// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel cs_main

RWTexture2D<float4> output_heat_map;
RWTexture2D<float4> output_time_map;
RWTexture2D<float4> output_time_map_with_top;

Texture2D<float4> _top_map;
SamplerState sampler_top_map;

StructuredBuffer<float2> places_been;
int places_been_count;
float bell_gain;
float end_gain;
float time_scale;

float4 hue_to_rgb(const in float h)
{
    float r = abs(h * 6 - 3) - 1;
    float g = 2 - abs(h * 6 - 2);
    float b = 2 - abs(h * 6 - 4);
    return saturate(float4(r,g,b,1));
}

[numthreads(32,32,1)]
void cs_main (uint3 id : SV_DispatchThreadID)
{
    float accumulated_amount = 0;
    float accumulated_time = 0;
    float some_time = 0;
    for (int i = 0; i < places_been_count; i++)
    {
        const float2 normalized_been_at = (places_been[i]+float2(5,5))/10.f;
        float nearness = distance(id.xy/2048.f, normalized_been_at); // Normalized distance, the further away the higher
        nearness = 1 - nearness*bell_gain;
        nearness = saturate(nearness)*end_gain;
        
        accumulated_amount += nearness;
        
        some_time += i;
        accumulated_time += nearness*some_time*time_scale;
    }
    
    accumulated_amount = pow(accumulated_amount, 0.2);
    const float heat_norm = clamp(accumulated_amount, 0.3, 1);
    output_heat_map[id.xy] = hue_to_rgb(1-heat_norm)*saturate(accumulated_amount*2);

    accumulated_time = pow(accumulated_time, 0.5);
    accumulated_time = frac(accumulated_time);
    const float4 time_color = hue_to_rgb(accumulated_time)*saturate(accumulated_amount*2);
    output_time_map[id.xy] = time_color;
    
    output_time_map_with_top[id.xy] = float4(time_color.xyz,0.5)+_top_map.SampleLevel(sampler_top_map, id.xy/2048.,0);
}